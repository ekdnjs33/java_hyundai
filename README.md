# Day01

### <표준출력>
    %s: 문자열 맵핑
    %d: 정수
    %f: 실수
    %c: 문자  
    %b: 논리값

### <데이터 종류>
    가. 기본형 데이터 ( 8가지 )
    수치형 - 정수형: byte (1byte)
                  short (2byte)
                  int (4byte)
                  long (8byte)

          - 실수형: float (4byte) : 3.14F
                  double(기본) (8byte) : 3.14, 3.14D

    문자형 : char (2byte)
        ==> escape 문자
            \t: 키보드 tab
            \n: 키보드 enter
            \": "출력
            \': '출력
            \\: \출력

    논리형 : boolean (1byte) : true/false(기본)

    나. 참조형 데이터
    ==> 기본형 8가지 제외한 나머지 모두 참조형 데이터이다.
    대표적으로 클래스, 배열, 인터페이스 (*****)

### <변수>
    가. 목적 : 데이터 저장

    나. 종류
        - 기본형 변수 : 기본형 데이터를 저장한 변수
          ==> 변수에 가면 실제 데이터값 저장

        - 참조형 변수 : 참조형 데이터를 저장한 변수
          ==> 변수에 가면 실제 데이터가 저장된 주소값이 저장
          ==> 클래스, 배열, 인터페이스는 주소값 저장, 크기는 항상 4byte

    다. 선언위치에 따른 변수 종류 ( 3가지 ) (*****)
        1. 로컬 변수
        - 메서드 안에 선언
        - 메서드 호출 ~ 매서드 종료시 제거
        - stack 메모리 저장
        - (주의) 사용 전, 반드시 초기화

        2. 인스턴스 변수
        - 메서드 밖에 선언
        - 객체 생성(new) ~ 객체 소멸시 제거
        - heap 메모리 저장
        - 자동 초기화 (정수: 0, 실수: 0.0, 논리: false, 참조형: null)

        2. 클래스 변수 (static 변수)
        - 메서드 밖에 선언
        - 프로그램 실행 ~ 프로그램 종료시 제거
        - method area 메모리 저장
        - 자동 초기화

    라. 데이터 형변환 ==> 데이터 종류 변경 가능
        1. 묵시적 형변환 (자동 형변환)
          a. byte > short > int > long > float > double
          b. char > int (아스키 코드) : char 값은 연산 가능
          c. int보다 작은 데이터형의 연산결과는 int로 반환
		      d. 작은타입과 큰타입 연산결과는 큰타입으로 반환

        2. 명시적 형변환 (강제 형변환)
           ==> (데이터형)변수

        데이터 형변환은 기본형 뿐 아니라 참조형도 가능 (* 클래스도 형변환 가능)

### <연산자>
    실행 결과가 논리값 반환하는 연산자?
        1. 비교연산자
        2. 논리연산자
        3. instanceof 연산자 : 실제 생성된 인스턴스타입 체크
           ==> name instanceof String (t/f)

    증감 연산자 주의할 점?
        ==> 다른 연산자와 같이 사용시 실행결과가 달라질 수 있다.
        (전치) ++num, --num : 먼저 증가하고 나중에 할당
        (후치) num++, num-- : 먼저 할당하고 나중에 증가

    3항 연산자
        변수명 = (조건식)?참:거짓;

### <배열>
    가. 변수 (variable)
        - 값 하나만 저장 가능 ==> 데이터가 많아지면 변수도 많아져, 관리 어려움
        - 사용방법
            a. 변수선언 : int n;
            b. 초기화
        - 기본형

    나. 배열 (array)
        - 여러 데이터를 변수(배열명) 하나로 관리 가능
        - 동일한 데이터타입만 관리
        - 사용방법
            a. 배열선언 : int [] num; // num은 참조형, 주소값, 로컬변수(stack)
            b. 배열생성 : num = new int[크기]; // new 이용, 인스턴스관련(heap)
            c. 초기화

    다. 참조형 데이터 : 클래스, 배열, 인터페이스 ==> 무조건 생성부터(new 이용)

    라. 배열 사용방법 ( 3가지 )
        1. new 이용 : int [] num = new int[2]; // 분리 가능
        2. 초기값 이용 (new 없이) : int [] num = {1, 2}; // 크기 지정 X
        3. 1 + 2 방법 혼합 :  int [] num; num = new int[]{1, 2}; // 분리 가능 + 크기 지정 X

    배열값을 문자열로 출력 = Arrays.toString({"A", "B"});
    배열값을 리스트로 생성 = List<String> list = Arrays.asList("A", "B");

### <클래스>
    가. 용어정리
        - 객체(object) : 현실세계의 사물을 의미 ==> 2가지 요소 (속성, 동작)
        - 클래스(class) : 객체의 자바문법 표현 방식(틀, 설계도)
        - 인스턴스(instance) : 메모리에 생성된 실제 값(실체)

    나. 자바 어플리케이션 개발 프로세스
      *분석 --> *설계 --> 구현 --> 테스트 --> 배포
      :객체 추출  :추출한 객체를 클래스 구현
                                            | 메모리 로딩 |
      학생 객체 ============> Student 클래스 ==> new 객체 생성 ======> 인스턴스
      속성 name ==========> 인스턴스 변수 ======> new 객체 생성 ======> 인스턴스
      동작 study =========> 메서드           

    다. 클래스 특징
        - 목적: 재사용
        - main이 없다.
        - 객체에 해당하는 클래스가 독자적으로 실행 안된다 ==> 메모리에 올릴 수 있는 클래스 필요(핸들링 클래스: TestMain)
        - 클래스 핸들링(객체 생성, 값 저장, 값 수정, 조회...)

        public class Student{
            1. 인스턴스 변수
              - 목적: 데이터 저장

            2. 메서드
              - 목적: 인스턴스 변수 관리

            3. 생성자 ==> 훨씬 빠른 시점에 인스턴스 초기화 가능
              - 목적: 인스턴스 변수 초기화
              - 특징: a. 명시적으로 생성자를 만들면 기본생성자 자동생성 안됨
                     b. 오버로딩 생성자(동일 이름의 생성자 여러개 사용 가능)
                        (변수 갯수 or 변수 타입 or 변수 순서) 반드시 달라야 한다.
        }

    라. 접근지정자(접근제어자) ==> 외부클래스에서 자신 접근 제약 지정
      - public: 제약 없다
      - protected: (default)
      - private: 자신만 접근

    객체 생성시 인스턴스 변수는 매번 생성된다. 이전 객체는 소멸, 중복 X
    this?
    객체 생성된 후 heap 메모리에 올라간 자신을 참조하는 키워드 (인스턴스 변수와 로컬 변수 이름이 같을 시 필수)
    this.name = name
    :인스턴스 변수  :로컬 변수

### <스태틱 static>
    가. static 변수 (static int count;)
        - 한번만 생성
        - 누적하는 용도
        - 클래스명.count
        - 자동초기화
        - new 무관(인스턴스)

    나. static 메서드 (public static int getCount(){})
        - new 없이 사용 가능
        - 목적: 편리, 싱글톤 객체(단 하나의 인스턴스만 생성하는 패턴)

    * static 영역은 method area, 프로그램 실행시 한번만 만들게 돼
    * static 변수 및 메서드는 반드시 클래스명을 지정해야 해

    다. API 중 대표적 static 메서드
        - Integer.parseInt()
        - String.valueOf()
        - Arrays.sort()
        - Arrays.toString()

# Day02
    객체지향프로그래밍(OOP) 3대 특징
        - 상속(inheritance)
        - 다형성(polymorphism)
        - 은닉화(캡슐화, encapsulation)

### <상속>
    상속: 공통된 속성을 뽑아 클래스를 만든다. (자식 클래스 extends 부모 클래스)
    Cat is a Pet 성립: Pet의 구성요소를 Cat이 그냥 사용 가능 (부모 생성자와 private은 상속 불가)

    가. 생성자 호출 형태 ( 3가지 )
        1. 다른 클래스에서 객체 생성시
            new 클래스명();
        2. 자식 클래스에서 부모 생성자 호출
            super(); (자식 클래스의 생성자 첫라인에 자동 삽입, 명시적 지정시 반드시 첫라인에 사용!)
        3. 같은 클래스의 특정 생성자에서 다른 생성자 호출
            this();

    나. 오버라이드 : 어노테이션 @Override는 현재메서드가 오버라이딩 메서드임을 알려주는 기능
        @Override
        public String getPet() {
            return super.getPet() + "\t" + color;
        }

    다. toString : 재정의
        @Override
        public String toString() {
            return "Dog [sex=" + sex + ", name=" + name + ", age=" + age + "]";
        }

    모든 사용자 정의 클래스 Object의 toString 재정의하자.
    ==> 명시적인 메서드 호출없이 원하는 객체 정보를 출력할 수 있다.

### <다형성>
    상속을 전제
    하나의 변수로 여러 데이터타입을 참조할 수 있다.
    문법: 부모클래스타입 변수 = new 자식클래스타입();
           Pet pet = new Cat();

### <은닉화>
    가. 접근지정자로 은닉화 구현
        private : 인스턴스 변수
        public: 메서드
        ==> 클래스 입장에서 효율적: 직접 접근하지 못하게 변수를 private 설정 ==> 올바른 데이터 설정 목적

    나. 메서드 private
        ==> 핸들링 클래스 입장에서 효율적: 사용하지 않는 메서드를 hide ==> 복잡성 감소

### <추상클래스
    추상메서드(abstract method)
      1. public abstract void 메서드명();
      2. 클래스는 반드시 abstract 로 지정
      3. 추상클래스 요소
          - 인스턴스 변수
          - 생성자
          - 일반 메서드(인스턴스 메서드)
          - 추상 메서드(abstract 메서드)
      4. 추상 클래스를 상속받은 자식에서는 반드시 추상 메서드를 재정의해야 된다.
          - 목적: 자식클래스에서 특정 메서드 강제 (통일성, 일관성)
      5. 추상 클래스는 new 불가
      6. 다형성 적용 가능
      ==> 여러 클래스에서 공통적인 메서드 사용하게 하자 (강제성 필요 ==> 추상클래스)

### <인터페이스>
    날아다니는 기능 메서드 fly() 어디에 추가?
        1. Pet 클래스에 추가
           ==> fly 기능이 없는 Cat과 Dog 문제
        2. Bird 클래스에 추가
           ==> Bird1, Bird2 마다 추가할 경우 서로 메서드가 다르게 구현, 관리 어려움
        3. 인터페이스에 추가 (**)
           public interface Flyer{
              public abstract void fly();
           }

    가. 인터페이스 구성요소 ( 4가지 )
        1. 상수
        ==> public static final 자동 지정
        2. 추상 메서드 (*****)
        ==> public abstract 자동 지정
        3. default 메서드
        ==> 일반 클래스의 인스턴스 메서드 기능과 동일
        4. static 메서드

    나. 추상 클래스와 인터페이스 비교
        1) 추상 클래스
            - public abstract class 클래스명{}
            - 구성요소 4가지
                a. 인스턴스 변수, 생성자, 인스턴스 메서드 ==> 일반 클래스 요소
                b. 추상 메서드(abstract)
            - 특징
                : new 불가
                : 임의의 클래스 이용해서 추상클래스 요소 사용, *상속관계, 단일 상속만 지원 (*****)
                ==> 임의의 클래스 extends 추상클래스
            - 목적
                : 하위 클래스에서 특정 메서드만 사용하도록 강제 + 일반 클래스의 상속 장점 제공
            - 단점
                : 다른 클래스를 상속 불가

        2) 인터페이스
            - public interface 인터페이스명{}
            - 구성요소 4가지
                : 상수, 추상메서드, default 메서드, static 메서드
            - 특징
                : new 불가(객체 생성 불가)
                : 임의의 클래스 이용해서 인터페이스 요소 사용, *구현관계, 다중 구현 가능 (*****)
                ==> 임의의 클래스 implements 인터페이스
                : 인터페이스간에 다중 상속 가능 (*****)
                ==> 인터페이스 extends 인터페이스
            - 목적
                : 하위 클래스에서 특정 메서드만 사용하도록 강제 + 클래스들간의 의존성 감소(decoupling)
